import { app, BrowserWindow, ipcMain } from "electron";
import path from "path";
import fs from "fs";
import ffmpeg from "fluent-ffmpeg";
import { VideoMetadata, VideoTypes } from "../types/video";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 700,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });
  mainWindow.setAspectRatio(8 / 7);
  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

app.on("ready", createWindow);

app.on("window-all-closed", () => {
  app.quit();
});

app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

export const extractThumbnail = (videoPath: string): Promise<Buffer> => {
  const thumbnailsDir = path.join(__dirname, "thumbnails");
  const thumbnailPath = path.join(
    thumbnailsDir,
    `${path.basename(videoPath)}.png`
  );

  // Ensure the thumbnails directory exists
  if (!fs.existsSync(thumbnailsDir)) {
    fs.mkdirSync(thumbnailsDir, { recursive: true });
  }

  // Check if the thumbnail already exists
  if (fs.existsSync(thumbnailPath)) {
    return fs.promises.readFile(thumbnailPath);
  }

  return new Promise<Buffer>((resolve, reject) => {
    ffmpeg(videoPath)
      .on("end", async () => {
        try {
          const data = await fs.promises.readFile(thumbnailPath);
          await fs.promises.unlink(thumbnailPath);
          resolve(data);
        } catch (error) {
          reject(error);
        }
      })
      .on("error", (error) => {
        reject(new Error(`FFmpeg error: ${error.message}`));
      })
      .screenshots({
        count: 1,
        folder: path.dirname(thumbnailPath),
        filename: path.basename(thumbnailPath),
        size: "320x240",
        timemarks: ["00:00:00.000"],
      });
  });
};

ipcMain.handle("get-library-metadata", async () => {
  try {
    const files = await fs.promises.readdir(app.getPath("videos"));
    const videoFiles = files.filter((file) => /\.(mp4|mkv|webm)$/i.test(file));

    const metadataPromises = videoFiles.map(async (file) => {
      const filePath = path.join(app.getPath("videos"), file);
      const thumbnailData = await extractThumbnail(filePath);

      return {
        name: file,
        path: filePath,
        type: path.extname(file).slice(1) as VideoTypes,
        thumbnail: `data:image/png;base64,${thumbnailData.toString("base64")}`,
      };
    });

    const results = await Promise.allSettled(metadataPromises);

    const metadata: VideoMetadata[] = results
      .filter((result) => result.status === "fulfilled")
      .map((result) => {
        if (result.status === "fulfilled") {
          return result.value;
        }
      });

    return metadata;
  } catch (error) {
    console.error("Error getting library metadata:", error);
  }
});

ipcMain.handle("get-video", async (event, videoPath) => {
  const filePath = path.join(app.getPath("videos"), videoPath);
  return fs.promises.readFile(filePath);
});

ipcMain.on("save-video", (event, videoBlob, mimeContainer) => {
  const filePath = path.join(
    app.getPath("videos"),
    `${Date.now().toLocaleString("en-US")}.${mimeContainer}`
  );
  fs.writeFile(filePath, Buffer.from(new Uint8Array(videoBlob)), (err) => {
    if (err) {
      console.error("Failed to save video", err);
    } else {
      event.reply("video-saved", filePath);
    }
  });
});
